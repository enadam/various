#!/bin/bash
#
# masstag -- tag MP3 files in batch
#
# Synopsis:
#   masstag [-2C] [-T <titles-file>] [<tags>...] [--] [<mp3-files>...]
#
# If <mp3-files> are not specified on the command line, first they are read
# from ./playlist, *.m3u, *.M3U, or *.M3u and then looking for *.mp3, *.MP3
# or *.Mp3 in the current directory, and finally read from the standard input.
#
# Options:
#   -2			Write ID3v2 tags with id3v2(1).  Otherwise,
#			mp3info(1) is used, but a warning is emitted
#			if a tag is truncated due to ID3v1's limitations.
#   -C			Commit changes.  If not specified, masstag just
#			prints the commands it would execute.
#   -T <titles-file>	Read and set the titles of <mp3-files> from
#			<titles-file>, which should contain one title
#			per line.  The number of titles should correspond
#			to the number of <mp3-files>.
#   -a <artist>, -{l|A} <album>, -y <year>, -g {<genre>|<genre-number>},
#   -c <comment>	Set the specified tag.  Only specified tags are
#			modified.
#   --<TAG> <value>	Set the specified tag (-2 mode only).
#   -n <trackno>	Designates the track number of the first file to
#			be processed.  Subsequent files get increasing
#			track numbers.  If not specified, track numbers
#			remain untouched.
#   --			End of options.

# The maximum length of an ID3v1 tag's value.
id3v1_maxlen=30;

# Parse the command line.
args=();
track="";
titles="";
id3v2="no";
testing="echo";
while [ $# -gt 0 ];
do
        case "$1" in
        --)
                shift;
                break;
                ;;
        -C)
                shift;
                testing="";
                ;;
	-2)
		shift;
		id3v2="yes";
		;;
        -[aAlygcTn]|--[A-Z]*)
		checklen="no";
                if [ $# -lt 2 ];
                then
                        echo "$0: required parameter missing" >&2;
                        exit 1;
                elif [ "x$1" = "x-T" ];
                then
                        titles="$2";
                elif [ "x$1" = "x-n" ];
                then
                        track="$2";
		elif [ "x$1" = "x-A" -o "x$1" = "x-l" ];
		then	# We accept both, but mp3info(1) and id3v2(1) need
			# different arguments.
			if [ "$id3v2" = "yes" ];
			then
				args[${#args[@]}]="-A";
			else
				args[${#args[@]}]="-l";
				checklen="yes";
			fi
			args[${#args[@]}]="$2";
                else
			case "$1" in
			-[ac])
				# Check the length of comments.
				checklen="yes";
				;;
			--*)
				if [ "$id3v2" = "no" ];
				then
					echo "$0: $1 can only be used " \
						"with ID3v2 tags" >&2;
					exit 1;
				fi
				;;
			esac

                        args[${#args[@]}]="$1";
                        args[${#args[@]}]="$2";
                fi

		# Check the tag value's lenght if necesssary.
		if [ "$id3v2" = "no" -a "$checklen" = "yes" \
			-a ${#2} -gt $id3v1_maxlen ];
		then
			echo "$0: value of $1 is too long for ID3v1" >&2;
		fi

                shift 2;
                ;;
	--)
		shift;
		break;
		;;
        -*)
                echo "$0: $1: unknown option" >&2;
                exit 1;
                ;;
	*)
                break;
                ;;
        esac
done

# Get the file names to be processed unless they're specified
# on the command line.
if [ $# -eq 0 ];
then
	found="no";
	shopt -s nullglob;
	for playlist in playlist *.m3u *.M3U *.M3u;
	do	# Read from a playlist file
		# Prevent bash from splitting on spaces.
		[ -f "$playlist" ] || continue;
		tmp="$IFS";
		IFS="
";
		# Mind \r\n line endings.
		set -- `tr -d '\r' < "$playlist"`;
		IFS="$tmp";
		found="yes";
	done

	if [ "$found" = "no" ];
	then	# Fail, look for MP3 files in the current directory.
		set -- *.mp3 *.MP3 *.M3u;

		if [ $# -eq 0 ];
		then	# Fail, read from standard input.
			while read mp3;
			do
				set -- "$@" "$mp3";
			done
		fi
	fi
fi

# Anything to do?
[ $# -gt 0 ] || exit 0;

# Which $prog to use for setting the tags?
if [ "$id3v2" = "no" ];
then
	prog="mp3info";
else
	prog="id3v2";
fi

# Anything special to do?
if [ "$titles" = "" -a "$track" = "" ];
then
	[ ${#args[@]} -gt 0 ] || exit 0;
	exec $testing $prog "${args[@]}" -- "$@";
fi

# Run
# We have six mode of operations: $titles or $track given or not,
# and which $prog to use.
if [ "$titles" != "" ];
then
	tr -d '\r' < "$titles" \
	| while :;
	do
		# Get $fname.  Are we finished?
		if [ $# -gt 0 ];
		then
			fname="$1";
			shift;
		else	# Check for excessive $titles.
			read title;
			if [ $? -eq 0 ];
			then
				echo "$0: too many titles" >&2;
				exit 1;
			fi
			break;
		fi

		# Get the title for $fname.
		read title;
		if [ $? -ne 0 ];
		then
			echo "$0: out of titles" >&2;
			exit 1;
		fi
		if [ "$id3v2" = "no" -a ${#title} -gt $id3v1_maxlen ];
		then
			echo "$0: title is too long for ID3v1" >&2;
		fi

		# Set the tags for $fname.
		if [ "$track" != "" ];
		then
			if [ "$id3v2" = "yes" ];
			then
				$testing $prog "${args[@]}" -t "$title" \
						 -T "$track" -- "$fname";
			else
				$testing $prog "${args[@]}" -t "$title" \
						 -n "$track" -- "$fname";
			fi
                        track=$((track+1));
		else
                        $testing $prog "${args[@]}" -t "$title" -- "$fname";
		fi
	done
	[ $? -eq 0 ] || exit $?;
else
	for fname;
	do
		# Set the tags for $fname.
		if [ "$track" != "" ];
		then
			if [ "$id3v2" = "yes" ];
			then
				$testing $prog "${args[@]}" -T "$track" \
					-- "$fname";
			else
				$testing $prog "${args[@]}" -n "$track" \
					-- "$fname";
			fi
                        track=$((track+1));
		else
                        $testing $prog "${args[@]}" -- "$fname";
		fi
	done
fi

# Done
exit 0;

# End of masstag
